load "iovtk"

// Global parameters
string OutputDir = "../data/";

real k = 1.;
real lambda = 2. * pi / k;

// Define the number I of sources with varying angles of incidence
int I = 2;
real[int] thetaSource(I);
thetaSource = 0 : (2 * pi / I) : 2 * pi;

// Export the angles of incidence
{
  ofstream fileoutput(OutputDir + "Thetasource.dat");
  fileoutput << thetaSource;
}

// Define the geometry (two imbricated circles of radius Rext and Rint)
real Rext = 5.;
real Rint = 3.;
int LabelExt = 1;
int LabelInt = 2;
border CercleExt(t = 0, 2. * pi) { x = Rext * cos(t); y = Rext * sin(t); label = LabelExt; }
border CercleInt(t = 0, 2. * pi) { x = Rint * cos(t); y = Rint * sin(t); label = LabelInt; }

// Define and build the mesh (triangular elements by default)
int delta = 10;
real NbPtOnExtBorder = 2 * pi * Rext * delta / lambda;
real NbPtOnIntBorder = 2 * pi * Rint * delta / lambda;
cout << "NbPtOnExtBorder = " << NbPtOnExtBorder << endl;
cout << "NbPtOnIntBorder = " << NbPtOnIntBorder << endl;
mesh Th = buildmesh(
  CercleExt(NbPtOnExtBorder)
  + CercleInt(NbPtOnIntBorder)
);

// Define an oriented boundary mesh of the external circle
int[int] labelObject = [LabelExt];
meshL ThL = extract(Th, label = labelObject);
ThL = OrientNormal(ThL, unbounded = 1);

// Plot the mesh
// plot(Th, wait = true, cmm = "Mesh");

// Define the point in the interior of the internal circle
int PtInt = Th(0., 0.).region;

// Define polynomials (P0 and P1) on the mesh to obtain finite element spaces and display their dimensions
fespace FS0(Th, P0);
fespace FS1(Th, P1);
fespace FSL(ThL, P1);
cout << "Dimension of the FS0 space: " << FS0.ndof << endl;
cout << "Dimension of the FS1 space: " << FS1.ndof << endl;
cout << "Dimension of the FSL space: " << FSL.ndof << endl;

// Define the contrast m (n1 - 1) : 2 * cos(x) in the internal circle and 0 outside
FS0 n0 = 1.0;
FS0 n1 = 2. * cos(x) * (region == PtInt) + n0 * (region != PtInt);
FS0<complex> m = n1 - n0;

// Plot the contrast m in P0
FS0 mRealP0 = n1 - n0; // To have real values for the plot
int nbiso = 20;
real[int] viso(nbiso);
viso = [-3.0, -2.9, -2.8, -2.7, -2.6, -2.5, -2.4, -2.3, -2.2, -2.1, -2.0, -1.9, -1.8, -1.7, -1.6, -1.5, -1.4, -1.3, -1.2, -1.1, -1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
// plot(mRealP0, value = 1, fill = 1, grey = 0, wait = true, viso=viso, cmm = "Contrast m in P0");

// Plot the contrast m in P1
FS1 mRealP1 = n1 - n0; // To have real values for the plot
// plot(mRealP1, value = 1, fill = 1, grey = 0, wait = true, viso=viso, cmm = "Contrast m in P1");

// Export the constrast m
{
  ofstream fileoutput(OutputDir + "Vectorm.dat");
  fileoutput << m[];
}

// Define the sesquilinear form of the left-hand side of the system.
// Add the boundary integral on the external circle for the radiation condition
// to enforce boundary condition.
// Then, discretize the operator using the Galerkin method,
// and prepare the solver for the later resolution of the linear system.
// /!\ The conjugate of v is not required by the software
varf a(u, v) = int2d(Th)(
  -dx(u) * dx(v) - dy(u) * dy(v) + k^2 * u * v
) + int1d(Th, LabelExt)(1.i * k * u * v);
matrix<complex> ABorn = a(FS1, FS1);
set(ABorn, solver = sparsesolver);

// As an example, this would be the operator for the non-linearized model
// without the Born approximation
// varf Bili(u, v) = int2d(Th)(
//   -dx(u) * dx(v) - dy(u) * dy(v) + k^2 * n1 * u * v
// ) + int1d(Th, LabelExt)(1.i * k * u * v);
// matrix<complex> A = Bili(FS1, FS1);

// Export the matrix ABorn
{
  ofstream fileoutput(OutputDir + "MatrixABorn.dat");
  fileoutput << ABorn;
}

// Define the sesquilinear form of the measurement.
// Then, discretize the operator using the Galerkin method.
// /!\ The conjugate of v is not required by the software
varf MesureTh(u, v) = int1d(Th, LabelExt)((dx(u) * N.x + dy(u) * N.y) * v);
matrix Ctmp = MesureTh(FS1, FS1);
matrix FS1toFSL = interpolate(FSL, FS1);
matrix C = FS1toFSL * Ctmp;

// Export the matrix C
{
  ofstream fileoutput(OutputDir + "MatrixC.dat");
  fileoutput << C;
}

for (int itercapteur = 0; itercapteur < I; itercapteur++) {

  // Define the incident plane wave for the current angle of incidence
  // PhiinftySource = exp(i (k . x))
  func uIncident = exp(1.i * k * (cos(thetaSource(itercapteur)) * x + sin(thetaSource(itercapteur)) * y));

  // Define the sesquilinear form of the right-hand side of the system.
  // Then, discretize the operator using the Galerkin method
  varf Lin(u, v) = int2d(Th)(u * k^2 * v * uIncident);
  matrix<complex> B = Lin(FS0, FS1);

  // Export the matrix B
  {
    ofstream fileoutput(OutputDir + "MatrixB_" + itercapteur + ".dat");
    fileoutput << B;
  }

  // Define the right-hand side of the system
  // to compute the scattered wave function usol.
  // Then, obtain the measurements
  varf LinIndice(unused, v) = int2d(Th)(m * k^2 * v * uIncident);
  complex[int] rhs = LinIndice(0., FS1);

  FS1<complex> usol;
  usol[] = ABorn^-1 * rhs;

  FSL<complex> Mesure;
  Mesure[] = C*usol[];

  // Export the measurements
  {
    ofstream fileoutput(OutputDir + "Vectord_" + itercapteur + ".dat");
    fileoutput << Mesure[];
  }
}
